# cs110-assignment-1-six-degrees-of-kevin-bacon-solved
**TO GET THIS SOLUTION VISIT:** [CS110 Assignment 1-Six Degrees of Kevin Bacon Solved](https://www.ankitcodinghub.com/product/cs110-assignment-1-six-degrees-of-kevin-bacon-solved/)


---

ğŸ“© **If you need this solution or have special requests:** **Email:** ankitcoding@gmail.com  
ğŸ“± **WhatsApp:** +1 419 877 7882  
ğŸ“„ **Get a quote instantly using this form:** [Ask Homework Questions](https://www.ankitcodinghub.com/services/ask-homework-questions/)

*We deliver fast, professional, and affordable academic help.*

---

<h2>Description</h2>



<div class="kk-star-ratings kksr-auto kksr-align-center kksr-valign-top" data-payload="{&quot;align&quot;:&quot;center&quot;,&quot;id&quot;:&quot;113676&quot;,&quot;slug&quot;:&quot;default&quot;,&quot;valign&quot;:&quot;top&quot;,&quot;ignore&quot;:&quot;&quot;,&quot;reference&quot;:&quot;auto&quot;,&quot;class&quot;:&quot;&quot;,&quot;count&quot;:&quot;1&quot;,&quot;legendonly&quot;:&quot;&quot;,&quot;readonly&quot;:&quot;&quot;,&quot;score&quot;:&quot;5&quot;,&quot;starsonly&quot;:&quot;&quot;,&quot;best&quot;:&quot;5&quot;,&quot;gap&quot;:&quot;4&quot;,&quot;greet&quot;:&quot;Rate this product&quot;,&quot;legend&quot;:&quot;5\/5 - (1 vote)&quot;,&quot;size&quot;:&quot;24&quot;,&quot;title&quot;:&quot;CS110  Assignment 1-Six Degrees of Kevin Bacon Solved&quot;,&quot;width&quot;:&quot;138&quot;,&quot;_legend&quot;:&quot;{score}\/{best} - ({count} {votes})&quot;,&quot;font_factor&quot;:&quot;1.25&quot;}">

<div class="kksr-stars">

<div class="kksr-stars-inactive">
            <div class="kksr-star" data-star="1" style="padding-right: 4px">


<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
            <div class="kksr-star" data-star="2" style="padding-right: 4px">


<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
            <div class="kksr-star" data-star="3" style="padding-right: 4px">


<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
            <div class="kksr-star" data-star="4" style="padding-right: 4px">


<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
            <div class="kksr-star" data-star="5" style="padding-right: 4px">


<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
    </div>

<div class="kksr-stars-active" style="width: 138px;">
            <div class="kksr-star" style="padding-right: 4px">


<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
            <div class="kksr-star" style="padding-right: 4px">


<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
            <div class="kksr-star" style="padding-right: 4px">


<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
            <div class="kksr-star" style="padding-right: 4px">


<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
            <div class="kksr-star" style="padding-right: 4px">


<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
    </div>
</div>


<div class="kksr-legend" style="font-size: 19.2px;">
            5/5 - (1 vote)    </div>
    </div>
When you think about Hollywood heavyweights, you donâ€™t immediately think of Kevin Bacon. But his career spans almost 20 years through films such as Flatliners, The Air Up There, Footloose, The River Wild, JFK and Animal House. So brush up on your Bacon lore. To play an Internet version, visit http://oracleofbacon.org.

This assignment is first and foremost a low-level systems programming assignment, but itâ€™s also an opportunity to review your C++ while simultaneously exercising your software engineering and low-level memory manipulation skills. Youâ€™ll also get to see that low-level C coding and high-level C++ data structuring can coexist in the same application.

The game takes the form of a trivia challenge: Propose two names, and your friend/opponent has to come up with a sequence of movies and mutual co-stars connecting the two. In this case, your opponent takes on the form of an executable, and that executable is shockingly good.

Jack Nicholson and Meryl Streep? Thatâ€™s easy:

poohbear@myth10$ ./search â€œMeryl Streepâ€ â€œJack Nicholson (I)â€ Meryl Streep was in â€œHeartburnâ€ (1986) with Jack Nicholson (I).

Mary Tyler Moore (rest her soul) and Red Buttons? Not so obvious:

poohbear@myth10$ ./search â€œMary Tyler Mooreâ€ â€œRed Buttonsâ€ Mary Tyler Moore was in â€œChange of Habitâ€ (1969) with Regis Toomey.

Regis Toomey was in â€œC.H.O.M.P.Sâ€ (1979) with Red Buttons.

Barry Manilow and Lou Rawls? Yes!

poohbear@myth10$ ./search â€œBarry Manilowâ€ â€œLou Rawlsâ€ Barry Manilow was in â€œBitter Jesterâ€ (2003) with Dom Irrera.

Dom Irrera was in â€œA Man Is Mostly Waterâ€ (2000) with Lou Rawls.

Itâ€™s the people youâ€™ve never heard of that are far away from each other:

poohbear@myth10$ ./search â€œDanzel Muzingoâ€ â€œLiseli Muttiâ€ Danzel Muzingo was in â€œMy Day in the Barrelâ€ (1998) with Damian Brown.

Damian Brown was in â€œBad Chemistryâ€ (1997) with Dick Welsbacher.

Dick Welsbacher was in â€œThe Atticâ€ (1980) with Carrie Snodgress.

Carrie Snodgress was in â€œChill Factorâ€ (1989) with Nathaniel Lees (I).

Nathaniel Lees (I) was in â€œRapa Nuiâ€ (1994) with Liseli Mutti.

Is it true? Your buffoon of a lecturer has a Bacon number of 3?

poohbear@myth10$ ./search â€œJerry Cainâ€ â€œKevin Bacon (I)â€ Jerry Cain was in â€œNo Rulesâ€ (2005) with Romeo Antonio.

Romeo Antonio was in â€œDoesnâ€™t Texas Ever Endâ€ (2009) with Irwin Keyes.

I have no idea who this particular Jerry Cain is, but itâ€™s certainly not me.

Overview

There are two major components to this assignment:

â— You need to provide the implementation for an imdb class, which allows you to determine who appeared in what. We could layer our imdb class over two STL mapsâ€”one mapping people to movies and another mapping movies to peopleâ€”but that would require we read in several megabytes of data from flat text files. That type of configuration takes several minutes, even on fast machines, and itâ€™s the opposite of fun if you have to sit that long before you play. Instead, youâ€™ll tap your sophisticated understanding of data representation and learn about something called memory mapping in order to look up movie and actor information from a prepared data structure thatâ€™s been saved to disk in its binary form (and Iâ€™ll describe the binary image format in the pages to come). This is the meatier part of the assignment. (By the way, imdb is short for Internet Movie Database. Our name is a gesture to the company that provides all of the data for the hundreds of thousands of movies and movie stars.)

â— You also need to implement a breadth-first search algorithm that consults your superclever imdb class to find the shortest path connecting any two actor/actresses. If the search goes on for so long that you can tell itâ€™ll be of length 7 or more, then you can be reasonably confident (and pretend that you know for sure that) thereâ€™s no path connecting them. This part of the assignment is more CS106B-like, and itâ€™s a chance to get a little more experience with the STL (using vectors, sets, and lists) and to see a legitimate scenario where a complex program benefits from coding in two different paradigms: high-level, object-oriented C++ (with its STL template containers and template algorithms) and low-level, imperative C (with its exposed memory, brought to you by CS107, *, &amp;, [], and -&gt;).

Task I: The imdb class

First off, I want to you complete the implementation of the imdb class. Hereâ€™s the reduced interface:

class imdb { public:

imdb(const string&amp; directory);

bool good() const;

bool getCredits(const string&amp; player, vector&lt;film&gt;&amp; films) const;

bool getCast(const film&amp; movie, vector&lt;string&gt;&amp; players) const;

~imdb();

private:

const void *actorFile;

const void *movieFile;

};struct film {

string title;

int year;

};

class imdb { public:

imdb(const string&amp; directory);

bool good() const;

bool getCredits(const string&amp; player, vector&lt;film&gt;&amp; films) const;

bool getCast(const film&amp; movie, vector&lt;string&gt;&amp; players) const;

~imdb();

private:

const void *actorFile; const void *movieFile;

};

The constructor and destructor have already been implemented for you. All the constructor does is initialize actorFile and movieFile fields to point to on-disk data structures using the mmap routine youâ€™ll learn about later on in the course. Since you havenâ€™t used mmap before, I implemented the constructor and destructor for you. (The destructor just munmaps what was mmap-ed at construction time).

Youâ€™ll need to implement the getCredits and getCast methods by manually crawling over these binary images in order to produce vectors of movies and actor names. When properly implemented, they provide lightning-speed access to a gargantuan amount of information, because the information is already compactly formatted in a preprepared data structure that permanently lives on the myth machines.

Understand up front that you are implementing these two methods to crawl over two arrays of bytes in order to synthesize data structures for the client. What appears below is a description of how that memory is laid out. You arenâ€™t responsible for creating the data files in any way, but you are just responsible for understanding how everything is encoded so that you can rehydrate information from their byte-level representations.

The Raw Data Files

The private actorFile and movieFile fields each address gigantic blocks of memory. Each is configured to point to mutually referent database images, and the format of each is described below. The imdb constructor sets these pointers up for you, so you can proceed as if everything is initialized for getCast and getCredits to just work.

For the purposes of illustration, letâ€™s assume that Hollywood has produced a mere three movies, and that theyâ€™ve always rotated through the same three actors whenever the time came to cast their three films. Letâ€™s pretend those three films are as follows:

â— Clerks, released in 1993, starring Cher and Liberace.

â— Moonstruck, released in 1988, starring Cher, Liberace, and Madonna.

â— Zoolander, released in 1999, starring Liberace and Madonna.

Remember, weâ€™re pretending.

If an imdb instance is configured to store the above information, you might imagine its actorFile and movieFile fields being initialized (by the constructor I already wrote for you) as follows:

Each of the records for the actors and movies will be of variable size. Some movie titles are longer than others; some films feature 75 actors, while others star only one or two. Some people have prolific careers, while several people are one-hit wonders. Defining a struct or class to overlay the blocks of data is a fine idea, except that doing so would constrain all records to be the same size. We donâ€™t want that, because weâ€™d be wasting a good chunk of memory when storing information on actors who appeared in just one or two films (and for films that feature just a handful of actors).

However, by allowing the individual records to be of variable size, we lose our ability to binary search (hint: via the STL lower_bound algorithm) a sorted array of records. The number of actors and actresses is circa 1.6 million, and the number of movies is in the hundreds of thousands, so a linear search would be all turtle-like. All of the actors and movies are sorted by name (and then by year if two movies have the same name), so binary search is still within reach. The strong desire to search quickly motivated my decision to format the data files like this:

Spliced in between the number of records and the records themselves is an array of integer offsets. Theyâ€™re drawn as pointers, but they really arenâ€™t stored that way. We want the data images to be relocatableâ€”that is, we want the information stored in the data images pointed to by actorFile and movieFile to be useful, regardless of what addresses get stored there. By storing integer offsets, we can manually compute the location of Cherâ€™s record, Madonnaâ€™s record, or Clerkâ€™s record, etc, by adding the corresponding offsets to whatever actorFile or movieFile turn out to be. A more accurate picture of what gets stored (and this is really what the file format is) is presented here.

Because the numbers are what they are, we would expect Cherâ€™s 16-byte record to sit 16 bytes from the front of actorFile, Liberaceâ€™s 24-byte record to sit 32 bytes within the actorFile image, and so forth. Looking for Moonstruck? Its 28-byte record can be found 36 bytes ahead of whatever address is stored in movieFile. Note that the actual offsets tell me where records are relative to the base address, and the differences between offsets tell me how large the actual records are.

Because all of the offsets are stored as four-byte integers (and ints are four bytes, even on 64-bit systems like the myths), and because they are in a sense sorted if the records they reference are sorted, we can use binary search. Woo!

To summarize:

â— actorFile points to a large mass of memory packing all of the information about all of the actors. The first four bytes store the number of actors (as an int); the next four bytes store the offset to the zeroth actor, the next four bytes store the offset to the first actor, and so forth. The last offset is followed by the zeroth record, then the first record, and so forth. The records themselves are sorted by name. Pinky swear they are.

â— movieFile also points to a large mass of memory, but this one packs the information about all films ever made. The first four bytes store the number of movies (again, as an int); the next *(int *)movieFile * sizeof(int) bytes store all of the int offsets, and everything beyond the offsets is real movie data. The movies are sorted by title, and those sharing the same title are sorted by year.

â— The above description above generalizes to files with 1,600,000 actors and 440,000 movies.

The Actor Record

The actor record is a packed set of bytes collecting information about an actor and the movies he or sheâ€™s appeared in. We donâ€™t use a struct or a class to overlay the memory associated with an actor, because doing so would constrain the record size to be constant for all actors. Instead, we lay out the relevant information in a series of bytes, the number of which depends on the length of the actorâ€™s name and the number of films heâ€™s appeared in. Hereâ€™s what gets manually placed within each entry:

1. The name of the actor is laid out character by character, as a normal null-terminated Cstring. If the length of the actorâ€™s name is even, then the string is padded with an extra â€ so that the total number of bytes dedicated to the name is always an even number. The information that follows the name is most easily interpreted as a short, and the myths might constrain addresses manipulated as short *s to be even.

2. The number of movies in which the actor has appeared, expressed as a two-byte short. (Some people have been in more than 255 movies, so a single byte isnâ€™t always enough). If the number of bytes dedicated to the actorâ€™s name (always even) and the short (always 2) isnâ€™t a multiple of four, then two additional â€â€™s appear after the two bytes storing the number of movies. This padding is conditionally done so that the four-byte integers than follow sit at addresses that are multiples of four (again, because the 64-bit mythâ€™s might be configured to require this).

3. An array of offsets into the movieFile image, where each offset identifies one of the actorâ€™s films.

Hereâ€™s what Cherâ€™s record would look like:

The Movie Record

The movie record is only slightly more complicated. The information is compressed is as follows:

1. The title of the movie, terminated by a â€, so the character array behaves as a normal Cstring incidentally wedged into a larger binary data figure.

2. The year the film was released, expressed as a single byte. This byte stores the year, minus 1900. Since Hollywood is less than 256 years old, it was fine to just store the year as an offset from 1900. If the total number of bytes used to encode the name and year of the movie is odd, then an extra â€ sits in between the one-byte year and the data that follows.

3. A two-byte short storing the number of actors appearing in the film, padded with two additional bytes of zeroes if needed.

4. An array of four-byte integer offsets, where each integer offset identifies one of the actors accessible via actorFile. The number of offsets here is, of course, equal to the short read during step 3.

One major gotcha: Some movies share the same title even though they are different. (The Manchurian Candidate, for instance, was first released in 1962, and then remade in 2004. Theyâ€™re two different films with two different casts.) If you look in the imdb-utils.h file, youâ€™ll see that the film struct provides operator&lt; and operator== methods. That means that two films know how to compare themselves to each other using infix == and &lt; (though not using !=, &gt;, &gt;=, or &lt;=). You can just rely on the &lt; and == to compare two film records. In fact, you have to, because the movies in the movieData binary image are sorted to respect film::operator&lt;.

Itâ€™s best to work on the implementation of the imdb class in isolation, not worrying about the details of the search algorithm youâ€™ll eventually need to write. Iâ€™ve provided a test harness to exercise the imdb all by itself, and that code sits in imdbtest.cc. The make system generates a test application called imdbtest which you can use to verify that your imdb implementation is solid. I provide my own version in ./slink/imdbtest_soln (slink is a symbolic link in your repo to a shared directory with solution executables) so you can run your version and my version side by side and make sure they match character for character.

Note: Your implementation will beâ€”and in fact is intended to beâ€”an interesting mix of C and C++. Youâ€™ll be relying on your mad C skillz to crawl over these binary images, and youâ€™ll be leveraging your C++ mastery to lift that data up into C++ objects. As part of your implementation, youâ€™ll need to binary search over the actor and movie offsets to find the actor or movie of interest.

I am requiring that you use the STL lower_bound algorithm to perform these binary searches, and that you use C++11 lambdas (also known as anonymous functions with capture clauses) to provide nameless comparison functions that lower_bound can use to guide its search.

Task II: Implementing Search

Youâ€™re back in pure C++ mode. At this point, Iâ€™m assuming your imdb class just works, and the fact that thereâ€™s some spectacularly shrewd pointer gymnastics going on in the imdb.cc file is completely disguised by the delightfully simple imdb interface. Use the services of your imdb and my path class (discussed below) to implement a breadth-first search for the shortest possible path. Leverage the STL containers as much as possible to get this done. Here are the STL classes I used in my solution:

â— vector: thereâ€™s no escaping this one, because the imdb requires we pull films and actors out of the binary images as vectors.

â— list: The list is a doubly-linked list that provides O(1) push_back, front, and pop_front operations. Thereâ€™s also a queue template, and you can use that if you want, but Iâ€™m so bugged that the STL queue calls its methods push and pop instead of enqueue and dequeue that I boycotted and used the list instead.

â— set: I used two sets to keep track of previously used actors and films. If youâ€™re implementing a breadth-first search and you encounter a movie or actor that youâ€™ve seen before, thereâ€™s no reason to use it/him/her a second time. You shouldnâ€™t need to use anything other than set::insert.

Getting Code

Go ahead and clone the mercurial repository that weâ€™ve set up for you by typing:

poohbear@myth10$ hg clone /usr/class/cs110/repos/assign1/$USER assign1

Compile often, test incrementally and almost as often as you blink, hgcommit a bunch so you donâ€™t lose your work in some bizarre rm disaster, and run /usr/class/cs110/tools/submit when youâ€™re done. As you make progress, you can invoke /usr/class/cs110/tools/sanitycheck to run a collection of tests that compare your solutions to my own. And be sure your solutions are free of memory leaks and errors, since weâ€™ll be running your code through valgrind. Note: thereâ€™s a bug in valgrind itself that surfaces when virtually any C++ program is run through it. You can suppress this error by copying the /usr/class/cs110/tools/config/.valgrindrc file into your home directory (or copying its contents into an existing ~/.valgrindrc file):

poohbear@myth10$ more /usr/class/cs110/tools/config/.valgrindrc â€“memcheck:leak-check=full

â€“show-reachable=yes â€“suppressions=/usr/class/cs110/tools/config/cs110.supp poohbear@myth10$ cp /usr/class/cs110/tools/config/.valgrindrc ~

Assignment 1 Files

Hereâ€™s the subset of all the files that pertain to just the first of the two tasks:

imdb-utils.h

The definition of the film struct, and an inlined function that finds the data files for you. You shouldnâ€™t need to change this file.

imdb.h

The interface for the imdb class. You shouldnâ€™t change the public interface of this file, though youâ€™re free to change the private section if it makes sense to.

imdb.cc

The implementation of the imdb constructor, destructor, and methods. This is where your code for getCast and getCredits belongs.

imdbtest.cc

The unit test code weâ€™ve provided to help you exercise your imdb. You shouldnâ€™t have to change this file.

Makefile

By typing makeimdbtest, youâ€™ll compile just the files needed to build imdbtest. You shouldnâ€™t need to change this file at all.

Everything from Task I (except imdbtest.cc) contributes to the overall search application. Type make search to build the search executable without building the imdbtest application (or you can just type make and build both.) Thereâ€™s a sample executable at ./slink/search_soln for you to play with. Understand that my sample application and yours arenâ€™t obligated to publish the same exact shortest path, but you should be sure that the path lengths themselves actually match. In addition to the files used for Task I, there are these:

search.cc

The file where most if not all of your Task II changes should be made.

path.h

The definition of the path class, which is a custom class useful for building paths between two actors. Youâ€™re free to add methods if you think itâ€™s sensible to do so.

path.cc

The implementation of the path class. Again, you can add stuff here if you think it makes sense to.
